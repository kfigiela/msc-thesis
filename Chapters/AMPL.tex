\chapter{Mathematical programming using AMPL}
\label{chap:ampl} 
\lhead{Chapter 3. \emph{Mathematical programming using AMPL}}


\section{Mathematical Programming}

The term \emph{programming} was in use by 1940 to describe planning and scheduling of activities. \emph{Programmers} found that they could represent the amount of each activity using variable that value was to be determined. Then by using equalities and inequalities they were able to mathematically describe restrictions inherent in the planning or scheduling problem. The solution satysfying all these constraints would be considered as acceptable plan or schedule. Mathematical programming enables us to formally define optimization problem: it's varialbes, objective and constraints.

It showed up soon that it was more complex that it initially appeared. It was more than merely specyfying constraints. If there were too few constraints, the space of possible solutions was too big. On the other hand, too many constraints could rule desirable solutions out. In the worst case there were no solutions at all. The success of programming relied on key insight into the optimized domain and modelling techniques to find a way round the possible difficulty. 

In addition to the constraints, one could define the objective – function of the variables that made it possible to compare solutions and select the best one. Then it didn't matter how many solutions satisfied the constraints -- we were interested in the one that minimized or maximized the objective.

In development of mathematical programming one kind of problem stands out: that in which all the costs, requirements and quantities are proportional to the variables. In other words, constraints and objectives are linear combinations of the variables. Such a program is called \emph{linear program} and the process of modelling and solving is called \emph{linear programming}. This class of optimization problems is particurarly important becasue a lot of real world optimization problems may be represented in such way. Additionally, there exists a lot of theory and algorithms to solve such problems in fast, deterministic way even if they have thousands of variables. The ideas of linear programming are also important for analyzing and solving problems that are non-linear.

All useful methods of mathematical programming involve using computers. It appeared very quickly in 1940s that computers may be used for scientific computing. The first computional method of solving optimization problems, the simplex algorithm, was introduced at that time and was subject to several improvements over the decades.

\subsection{Problem classification}
\label{ampl:classification}

In spite of the broad applications of linear programming, the linearity assumption is too unrealistic to be applied to many of real problems. If instead smooth non-linear functions of the variables are used in constraints and objectives we call the program as \emph{non-linear program}. Solving such problems is much harder, but not impossible.

There is also another class of problems called \emph{integer programming} that assumes that variables are integer and in general it is much harder than previous. Fortuanetly, computational power of computers is still increasing and there are efficient algorithms to deal with them.

The optimization problems may be categorized in the following groups:
\begin{description}
  \item[Linear programming (LP)] Objective and constraints in this class are linear functions. Problems in this groups are usually solved by using \emph{simplex}, \emph{interior} or \emph{barrier} method.
  \item[Quadratic programming (QP)] Convex or concave objective and linear constraints. Solved by simplex-type or interior-type method.
  \item[Non-linear programming (NLP)] Continuous, but not all-linear objective and constraints. May be solved by several methods including gradient, quasi-newton, augmented lagrangian and interior-point. Unless special conditions are met, solution found is possibly optimal over only some local neighbourhood. If objective is convex (if minimized) or concave (if maximized) and constraints define a convex region it is guaranteed that optimum found is optimal over the entire feasible region.
  \item[Mixed-integer programming (MIP)] Linear objective and constraints, some or all of variables are integer-valued. Solved by branch-and-bound approach that uses a linear solver to solve subproblems.
  \item[Mixed-integer non-linear programming (MINLP)] Non-linear objective and constraints, some or all of variables are integer-valued. Solved by branch-and-bound approach that uses a non-linear solver to solve subproblems.
  \item[Constraint programming (CP)] \emph{TODO: pisac o tym w ogole?}
\end{description}

\section{AMPL: A Mathematical Programming Language}

To successfully solve optimization problem one needs to do a sequence of multiple tasks such as:

\begin{itemize}
  \item Formulate an abstract model: define variables, constraints and objective.
  \item Collect the data for a specific problem instance.
  \item Generate instance-specific variables, constraints and objective.
  \item Solve the problem by running a program called solver that implements algorithm that finds optimal solution.
  \item Analyze the results.
  \item Refine the model and the data as necessary, and repeat.
\end{itemize}

Unfortuanetly, usually people use diffrent form of representing the data than algorithms do. This makes formulation and generation phases complex as modeller would like to express constraints in human-readable language e.g. mathematical notation, and solvers require to provide multiple matrixes as input. We need to transform \emph{modeller's form} to \emph{algorithm's form} and doing it manually is time consuming and erron-prone task.

To automate this task matrix generators were created for specific models. Altough they successfully automate matrix generation they are hard to code, debug and maintain. Modeller needs to be both mathematician and programmer. The other way to solve that problem is to use mathematical modelling language. Several languages were created \footnote{i.e. AMPL, Gams, PuLP, OscaR} over the decades. 

By using modelling language, modeller may express in comfortable way also designed to serve as input for the computer. Then matrix generation may be fully automated without intermediate state of computer programming, thus mathematical programming becomes cheaper and more reliable. Benefits of formulating in modelling languages become particuraly advantageous for models being developed and subject to change.

AMPL is an algebraic mathematical modelling lanuage that resembles traditional mathematical notation to describe variables, objectives and constraints. Code in AMPL will be familiar for anybody that studied basic algebra or calculus, so that he or she doesn't need to be programmer. Algebraic modelling languages allow to express a wide range of optimization problems linear, nonlinear and integer.

\subsection{Available solvers}

As soon as model is formulated and matrices generated, we may proceed with solving the specific instance of our problem. To do that we will need solver -- a program that implements one of solving algorithms. There is wide range of existing solvers available, both open-source (i.e. Cbc\footnote{https://projects.coin-or.org/Cbc}) and commercial (i.e. CPLEX\footnote{http://www-01.ibm.com/software/commerce/optimization/cplex-optimizer/}) ones that differ with the problem classes they target. Full list of available solvers is published at AMPL website\footnote{http://www.ampl.com/solvers.html}.

Usually solvers provide multiple options that let us tune them for the specific application. One may enable or disable certain features of the solver, i.e. for \emph{Bonim} solver we may choose branching algorithm or configure it to use heuristics.

\subsection{Example 1: ??}
\subsection{Example 2: ??}

\emph{TODO: Tutaj dwa przyklady, jeden najlepiej liniowy, a drugi integerowy – znajdzie sie cos klasycznego w AMPL booku}